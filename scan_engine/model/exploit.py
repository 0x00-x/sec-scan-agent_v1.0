#!/usr/bin/env python
#coding:utf-8
#__author__:Bing

import os
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '../thirdparty'))

import json
from scan_engine.thirdparty import colorama
from dotted import DottedDict
from abc import ABCMeta, abstractmethod
colorama.init()
import threading,time,Queue

class CTConvert(object):
    @staticmethod
    def int_field(string):
        assert isinstance(string, (basestring, int))
        return int(string)

    @staticmethod
    def str_field(string):
        assert isinstance(string, basestring)
        return str(string)

    @staticmethod
    def bool_field(string):
        assert isinstance(string, (basestring, int))
        if string.lower() == 'false' or string == '0':
            return False
        return bool(string)

    @staticmethod
    def json_field(string):
        assert isinstance(string, basestring)
        return json.loads(string)

    @staticmethod
    def url_field(string):
        assert isinstance(string, basestring)
        domain = string if string.starCTwith('http') else "http://{domain}".format(domain=string)
        print domain
        return str(domain)

    @staticmethod
    def email_field(string):
        # TODO: there is no need to implement this in here
        assert isinstance(string, basestring)
        return string



class CTSeverity(object):
    """
    Σ���ȼ�
    """
    high = 'high'
    medium = 'medium'
    low = 'low'


class CTType(object):
    injection = 'SQL injection'
    xss = 'xss cross site attack'
    xxe = 'xml external entity attack'
    file_upload = 'Arbitrary file upload'
    file_operation = 'Arbitrary file operation'
    file_traversal = 'directory traversal'
    rce = 'Remote command / code execution'
    lfi = 'Local file contains'
    rfi = 'Remote file contains'
    info_leak = 'Information leakage'
    misconfiguration = 'Error configuration'
    other = 'Other'
	

class CTExploit(object):
    __metaclass__ = ABCMeta

    type = CTType()
    convert = CTConvert()
    severity = CTSeverity()


    def __init__(self):
        super(CTExploit, self).__init__()
        self.option = {}
        self.result = {}

    def register_option(self, dict_option):
        assert isinstance(dict_option, dict)
        self.option = DottedDict(dict_option)

    def register_result(self, dict_result):
        assert isinstance(dict_result, dict)
        self.result = DottedDict(dict_result)
		
    def thread(self,func,args,thr):
		'''[1] the func to run,[2] the func's args,[3] the thread nums'''
		q = Queue.Queue()
		t = []
		def start(q):
			while not q.empty():
				func(q.get())
		for a in args:
			q.put(a)
		for i in range(int(thr)):
			tt = threading.Thread(target=start,args=(q,))
			t.append(tt)
		for i in range(int(thr)):
			t[i].start()
		for i in range(int(thr)):
			#t[i].join(timeout=10)
			t[i].join()

    @staticmethod
    def is_sanbox():
        import os
        if os.environ.get('APP_NAME', None):
            return True

    @abstractmethod
    def verify(self):
        pass


		